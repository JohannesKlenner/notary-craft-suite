üéØ Projektziel
Erstelle ein lokal ausf√ºhrbares Backend (‚ÄûServer‚Äú) f√ºr eine Desktop-App namens ‚ÄûNotary Tools‚Äú. Die App stellt mehrere juristische Tools bereit. Das Backend versorgt das Frontend (Loveable) via FastAPI (lokal) mit Daten und Businesslogik. Die Daten werden persistent in einer lokalen SQLite-Datenbank gespeichert.

‚úÖ Anforderungen im Detail
üîê 1. Benutzerverwaltung
Benutzeranmeldung (Benutzername + Passwort mit bcrypt-Hash lokal)

Benutzerrollen (‚ÄûAdmin‚Äú und ‚ÄûStandardnutzer‚Äú)

Nur Admin darf Benutzer hinzuf√ºgen, √§ndern, l√∂schen

Passwort√§nderung durch Admin m√∂glich

Session-Management via Tokens (JWT empfohlen)

üß© 2. Modulstruktur Backend
Jedes Tool erh√§lt eigenes Python-Modul in Ordnerstruktur:

arduino
Kopieren
Bearbeiten
backend/
‚îú‚îÄ‚îÄ main.py (FastAPI Einstiegspunkt)
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îî‚îÄ‚îÄ db.py (SQLite-Verbindung, SQLAlchemy ORM empfohlen)
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îî‚îÄ‚îÄ users.py (Benutzerverwaltung)
‚îú‚îÄ‚îÄ tools/
‚îÇ   ‚îú‚îÄ‚îÄ erbfolge.py
‚îÇ   ‚îú‚îÄ‚îÄ miteigentum.py
‚îÇ   ‚îî‚îÄ‚îÄ ... (weitere Tools sp√§ter hier erg√§nzen)
‚îú‚îÄ‚îÄ export/
‚îÇ   ‚îî‚îÄ‚îÄ exporter.py (PDF, CSV, RTF, GedCOM, sp√§ter DOCX, MD)
‚îú‚îÄ‚îÄ feedback/
‚îÇ   ‚îî‚îÄ‚îÄ email.py (Feedback-Mailversand)
‚îî‚îÄ‚îÄ config.py (SMTP-Einstellungen etc.)
üìÅ 3. Speicherung
SQLite-Datenbank f√ºr persistente Speicherung aller Daten lokal im Netzwerk (erm√∂glicht Mehrbenutzer-Betrieb via Netzwerkfreigabe)

SQLAlchemy als ORM verwenden

Historienfunktion: Automatisches Speichern zuletzt genutzter Vorg√§nge je Tool in DB (Timestamp, User, Toolname, JSON-Daten)

üì§ 4. Export-Funktion
Zentrales Export-Modul (exporter.py) mit Funktionen f√ºr:

PDF, CSV, RTF

GEDCOM (spezifische Tools wie ‚ÄûErbfolge‚Äú)

DOCX, Markdown sp√§ter vorbereiten (optional)

Einheitliche Schnittstelle, Frontend ruft API an, erh√§lt Datei als Download zur√ºck

üìß 5. Feedback-Funktion
Versand von Feedback via SMTP (externer Provider), Anh√§nge (Screenshots) erlaubt

Admin konfiguriert SMTP-Einstellungen (Adresse, Port, User, Passwort) in config.py

üîÑ 6. Schnittstelle (FastAPI)
REST API mit sauberer Swagger-/OpenAPI-Dokumentation

JSON-basierte Kommunikation:

Authentifizierung via JWT (Bearer-Token)

Tools haben je eigene Endpunkte

Exportfunktionen separate Endpunkte (/export/pdf, /export/csv usw.)

Beispiel-Endpunkte:

bash
Kopieren
Bearbeiten
POST /login -> JWT Token
GET /tools/erbfolge/{case_id} -> JSON-Daten
POST /tools/erbfolge -> Neuer Vorgang erstellen
POST /export/pdf -> PDF erzeugen & liefern
POST /feedback/send -> Feedback-Mail senden
üõ†Ô∏è Technische Vorgaben
Python 3.11+

FastAPI als lokaler Webserver f√ºr API

SQLAlchemy als ORM f√ºr SQLite

bcrypt f√ºr Passwort-Hashes

JWT (PyJWT) f√ºr Authentifizierung

pytest f√ºr Unit-Tests

üóÉÔ∏è SQLite-Datenbankschema (initiale Struktur)
sql
Kopieren
Bearbeiten
users (
  id INTEGER PRIMARY KEY,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT NOT NULL,
  role TEXT NOT NULL,
  created TIMESTAMP DEFAULT CURRENT_TIMESTAMP
)

tool_history (
  id INTEGER PRIMARY KEY,
  user_id INTEGER,
  tool_name TEXT,
  json_data TEXT,
  last_used TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  FOREIGN KEY(user_id) REFERENCES users(id)
)

smtp_config (
  id INTEGER PRIMARY KEY,
  smtp_server TEXT,
  smtp_port INTEGER,
  smtp_user TEXT,
  smtp_password TEXT
)
üìå Besondere Hinweise zur sp√§teren Erweiterbarkeit
Bereite eine m√∂gliche sp√§tere Anbindung an eine externe SQLBase-Datenbank (Advoware) vor. (Noch nicht implementieren, aber im Hinterkopf behalten. FastAPI existiert hierf√ºr bereits separat.)

Struktur sauber und modular halten, um sp√§tere Erweiterungen problemlos zu erm√∂glichen.

‚úÖ Zusammenfassung der Entscheidungen
Kriterium	Entscheidung
Benutzerdatenbank	SQLite lokal (netzwerkf√§hig)
Benutzerverwaltung	Nur Admin legt Benutzer an
Kommunikation Frontend-Backend	FastAPI lokal
Speicherung/Verlauf	SQLite (SQLAlchemy ORM)
Exportformate	PDF, CSV, RTF, GedCOM (DOCX/MD sp√§ter m√∂glich)
SMTP-Mail	Admin konfigurierbar (extern)
Betrieb Backend	Dauerhaft lokal
API-Dokumentation	Ja (Swagger/OpenAPI)
Unit-Tests	Ja (pytest)